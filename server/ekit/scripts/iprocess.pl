#!/usr/bin/perl
#$Id: iprocess.pl,v 2.28 2011-07-26 21:04:41 triton Exp $
#Copyright 2001 Triton Technology
$|++; # unbuffer stdoout.
use strict;							#perl2exe
use File::Slurp;					#perl2exe
use File::Spec;						#perl2exe
use File::Spec::Win32;				#perl2exe
use File::Path;						#perl2exe
use FileHandle;						#perl2exe
use Data::Dumper;					#perl2exe
use Tie::IxHash;					#perl2exe
use Getopt::Long;					#perl2exe
use Date::Manip;					#perl2exe
use List::Util qw(max);             #perl2exe
use Data::Dump qw(dump);            #perl2exe
use DirHandle;                      #perl2exe
use Math::Round qw(nearest);        #perl2exe

use TPerl::TritonConfig qw(getConfig getdbConfig);	#perl2exe
use TPerl::Error;					#perl2exe
use TPerl::Parser;					#perl2exe
use TPerl::Dump;					#perl2exe
use TPerl::DBEasy;					#perl2exe
use TPerl::Survey;                  #perl2exe
use TPerl::Survey::Question;        #perl2exe
# use TPerl::Object;				#perl2exe
# don't use this anymore.


my $version = q{$Id: iprocess.pl,v 2.28 2011-07-26 21:04:41 triton Exp $};

my $troot = getConfig ('TritonRoot');
my $data = 'web';

my $variables=0;
my $masks=0;
my $maskts=0;
my $debug=0;
my $seq = [];
# my $complete_only=1;
my $offset = 0;
my $dots = 1;
my $label_data = 0;
my $help = 0;
my $showhash = [];
my $pretty_start = undef;
my $pretty_end = undef;
my $name_ext = '';
my $replace = 1;
my $print_ver = 0;
my $numeric_passwords = 0;
my $seqno_fix = 1;
my $status_inc = [4];
my $status_exc = [];
my $cases = 0; # use the CASES table as generated by slurp
my $mn_notes = 0;
my $one_line_output = 0;
my $do_specify_files = 1;
my $duration_minutes_near = 1;


GetOptions (
	'dots!'=>\$dots,
	'variables!'=>\$variables,
	'masks!'=>\$masks,
	'maskts!'=>\$maskts,
	# 'completes!'=>\$complete_only,
	'debug!'=>\$debug,
	'seq:s'=>$seq,
	'offset:i'=>\$offset,
	'label_data+'=>\$label_data,
	'help+'=>\$help,
	'showhash:s'=>$showhash,
	'start:s'=>\$pretty_start,
	'end:s'=>\$pretty_end,
	'ext|name_ext:s'=>\$name_ext,
	'replace!'=>\$replace,
	'version!'=>\$print_ver,
	'fix_seqno!'=>\$seqno_fix,
	'numericpasswords!'=>\$numeric_passwords,
	'data:s'=>\$data,
	'is:i'=>$status_inc,
	'es:i'=>$status_exc,
	'cases!'=>\$cases,
	'marginnotes!'=>\$mn_notes,
	'one_line!'=>\$one_line_output,
	'specify_files!'=>\$do_specify_files,
	'dur_min_near:i'=>\$duration_minutes_near,

)or usage( 'Bad Command option');
usage () if $help;
my $err = new TPerl::Error(ts=>$debug);
sub usage {
    print @_;
    print "\n";
    print qq{ Usage: $0 [options] Survey_ID
 Options Include
  --help  
  --(no)variables				include variables from the invite file
  --debug												increase debug information
  --seq 123										show only these dfiles
  --label												label data with the question number
  --start												include dates after this (default 1/1/1970)
  --end														include dates before this (default tomorrow)
  --numeric										include numeric passwords (off by default)
  --showhash									(debugging - show various internal hashes minuses codes )
  --(no)replace						replace data file if it exists
  --(no)fix_seqno				make sure the seqno matches the Dfile name
  --data													Specify alternate data dir to read from.  defaults to web
  --is															status value to include (can repeat this option)
  --es															status value to exclude (can repeat this option)
  --cases												use the cases table generated by tslurp
  --marginnotes						pump out a margin notes file.
  --dur_min_near XX		round duration_minutes to nearest XX
};
## Please see file perltidy.ERR
	exit;
}


sub dates {
    my %args   = @_;
    my $start  = $args{start};
    my $end    = $args{end};
    my $offset = $args{offset};

    my $diff = int(  $end - $start  );

    # print "st=$start, end=$end\n";
    $diff = 0 if $diff < 0;
    my ( $sec, $min, $hr, $mday, $mon, $myear, $wday, $yday, $isdst ) =
      localtime( $start + $offset );
    return {
		duration_minutes => nearest($duration_minutes_near,$diff/60),
        duration => $diff,
        year     => $myear + 1900,
        month    => $mon + 1,
        day      => $mday,
        weekday  => $wday + 1,
        hour     => $hr,
        minute   => $min
    };

}

usage ($version) if $print_ver;

my $sep = '===';
my $SID = shift;

usage ("No SID supplied") unless $SID;

##### date stuff...
###Epoch start and end for comparing with elements of the resp hash
my ($start,$end);
my $ez = new TPerl::DBEasy;
if ($pretty_start || $pretty_end){
	my $defstart = 'Jan 1 1970';
	my $defend = 'Tomorrow';
	$pretty_start ||= $defstart;
	$pretty_end ||= $defend;
	if ($start = $ez->text2epoch ($pretty_start)){
		# $err->I("Data collected after $pretty_start ($start)") unless $one_line_output;
	}else{
		$err->I("Could not understand start date $pretty_start");
		$pretty_start =$defstart;
		$start = $ez->text2epoch($pretty_start);
		# $err->I("Data collected after $pretty_start");
	}
	if ($end = $ez->text2epoch ($pretty_end)){
		# $err->I("Data collected before $pretty_end ($end)") unless $one_line_output;
	}else{
		$err->I("Could not understand end date $pretty_end");
		$pretty_end =$defend;
		$end = $ez->text2epoch($pretty_end);
		# $err->I("Data collected before $pretty_end");
	}
	$err->I("Data collected bw '$pretty_start' and '$pretty_end'") unless $one_line_output;
	unless ($name_ext){
		$name_ext = "_$pretty_start-$pretty_end";
		$name_ext =~ s/\s+/_/g;
		$err->I("Output in $name_ext");
	}
}

my $src = "$troot/$SID/$data";
mkpath ("$troot/$SID/final/",1) unless -e "$troot/$SID/final/";
$name_ext ="_$name_ext" if $name_ext && $name_ext !~ /^_/;
my $dest = "$troot/$SID/final/$SID$name_ext.txt";

usage ("Source dir $src does not exist") unless -e $src;
unless ($replace){
	if (-e $dest){
		$err->I("Output file '$dest' exists. quitting now") unless $one_line_output;
		exit;
	}
}
my $ofh = new FileHandle ("> $dest") or $err->F("cannot write desintation file $dest");
$err->I("Creating File '$dest'") unless $one_line_output;
$err->I("Labeling data with column name") if $label_data && !$one_line_output;

$err->D("Reading from $src writing $dest") if $debug && !$one_line_output;
foreach (@$seq){
	$_ = "D$_.pl";
}
$err->D("Sequences @$seq") if $debug and @$seq;

my $mn_fh;
if ($mn_notes){
	my $mn_fn = join '/',$troot,$SID,'final',$SID."_margin_notes$name_ext.txt";
	$mn_fh = new FileHandle ("> $mn_fn") or $err->F("Cannot open margin notes $mn_fn for writing");
	$err->I("Writing margin notes file to '$mn_fn'") unless $one_line_output;
}

## The stuff that is in each survey. l means label d is how to find the info in the %resp hash
	# or in the dates hash is s is set. the dates hash comes from sub dates.
my @all_survey_fields = (
		{l=>'Status',d=>'status'},
		{l=>'Seqno',d=>'seqno'},
		{l=>'SurveyID',d=>'survey_id'},
		{l=>'Email',d=>'email'},
		{l=>'Ipaddr',d=>'ipaddr'},
		{l=>'Duration',d=>'duration',s=>'f'},
		{l=>'Duration-mins',d=>'duration_minutes',s=>'f'},
		{l=>'Year',d=>'year',s=>'f'},
		{l=>'Month',d=>'month',s=>'f'},
		{l=>'Day',d=>'day',s=>'f'},
		{l=>'Weekday',d=>'weekday',s=>'f'},
		{l=>'hour',d=>'hour',s=>'f'},
		{l=>'min',d=>'minute',s=>'f'},
		{l=>'Token',d=>'token'},
		{l=>'Id',d=>'id'},
		{l=>'lastq',d=>'lastq'},
		{l=>'Version',d=>'ver'},
		{l=>'Modified',d=>'modified'},
		{l=>'Modified_s',d=>'modified_s'},
		{l=>'UserAgent',d=>'agent'},
);

# see if we are going  to recode dk or refused
# my $confpl = config TPerl::Object (file=>"$troot/$SID/config/config.pl",err=>$err);
# $err->I("Number DK become $confpl->{code_number_dk}") if defined $confpl->{code_number_dk};
# $err->I("Number Refused become $confpl->{code_number_refused}") if defined $confpl->{code_number_refused};
# $err->I("Ageonset DK become $confpl->{code_age_dk}") if defined $confpl->{code_age_dk};
# $err->I("Ageonset Refused become $confpl->{code_age_refused}") if defined $confpl->{code_age_refused};

#### include_status is the hash of statuses to include.
my %include_status = ();
$include_status{$_}++ foreach @$status_inc;
delete $include_status{$_} foreach @$status_exc;
$status_inc = [sort {$a <=> $b} keys %include_status];
$err->I("Including status values: @$status_inc") unless $one_line_output;

my $survey_file = join '/',$troot,$SID,'config',$SID.'_survey.pl';
$err->F("Survey File $survey_file does not exist.  run qfiles") unless -e $survey_file;
my $s = getro TPerl::Dump $survey_file;

my $rfdk = {};
foreach (qw (rf dk)){
	$rfdk->{$_} = $s->options->{$_.'_code'};
	$err->I("Will set blank '$_' data to '$rfdk->{$_}'") if $rfdk->{$_};
}

my $case_hash = undef;
if ($cases){
	if (my $db = getdbConfig('EngineDB')){
		if (my $dbh = dbh TPerl::MyDB (db=>$db)){
			my $table = $SID."_CASE";
			$err->F("Table $table in db '$db' does not exist") unless grep /^$table$/,$dbh->tables;
			my $sql = "select * from $table";
			if ($case_hash = $dbh->selectall_hashref($sql,'SEQ')){
				if (my $ncases = keys (%$case_hash)){
					$err->I("Using --cases. Found $ncases cases in table $db.$table");
				}else{
					$err->F("No data in $table");
				}
			}else{
				$err->F("Could not execute '$sql' in db '$db'".$TPerl::MyDB->err());
			}
		}else{
			$err->F( "Could not connect to db '$db':".TPerl::MyDB->err());
		}
	}else{
		$err->F ("Using --cases but no 'EngineDB' from getdbConfig");
	}
}


$err->I("Initial Dfile pass") unless $one_line_output;

## Now some ext_ are in the cis, we need to track them and then not put them into the externals hash.  we only want them once in data file.
my $ext_in_cis = {};
foreach my $q (@{$s->questions}){
	my $type = $q->qtype;
	foreach my $ci (@{$q->getDataInfo}){
		$ext_in_cis->{$ci->{rkey}}++ if $type == 7;
	}
}
my $mn_that_exist = {};
my $externals = {};
my $bad_dfiles = {};
my $vars = {};
my $mask_widths = {}; 
my $ete = {}; #everything else.
{
	my $dh = new DirHandle ($src) or $err->F("Could not access dir $src:$!");
	while (my $f = $dh->read){
		last unless defined $f;
		my ($num_seq) = $f =~ /^D(\d+)\.pl$/i;
		next if $num_seq eq '' ;
		next if $case_hash and !$case_hash->{$num_seq};
		next if @$seq && !grep $f eq $_,@$seq ;
		my %resp = ();
		my @line=();
		eval read_file("$src/$f");
		if ($@){
			$err->E("Eval error in $f:$@");
			$bad_dfiles->{$f}++;
			next;
		}
		if (!$numeric_passwords){
			next if $resp{token} =~ /^\d+$/;
		}
		next unless $include_status{$resp{status}};
		if ($start || $end){
			$resp{start} = $resp{modified} if $resp{start} eq '';
			next if $resp{start} < $start;
			next if $resp{modified} > $end;
	 		# foreach ($start, $resp{modified}, $end){
	 		# 	print "$_ ".$ez->epoch2text($_).' ';
	 		# }
	 		# print "$start $resp{start} $end\n";
		}
		foreach my $k (keys %resp){
			# print "FOUND $k\n" if $k =~/box/i;
			# print "FOUND $k\n" ;#if $k =~/box/i;
			next if $ext_in_cis->{$k};
			next if $k =~ /^ext_radio/;
			next if $k =~ /^ext_grid/;
			$externals->{$k}++ if $k =~ /^ext_/ ;
			if ($variables and $k =~ /^v/ ){
				next if $k =~ /^ver$/;
				next if $k =~ /^vscore/;
				next if $k =~ /^vq/;
				next if $k =~ /^ver$/;
				next if $externals->{$k};
				$vars->{$k}++;
			}
			if ($masks){
				if (my ($mn) = $k=~ /^maskt?_(.*)$/){
					my @ary = split /$sep/,$resp{$k};
					$mask_widths->{$mn} = @ary if @ary >$mask_widths->{$mn};
				}
			}
			next if $k =~/^_/;
			next if $k =~/^v/;
			next if $k =~/^mask/;
			next if $k =~/^q/;
			next if $k =~/^\d+/;
			next if grep $k eq $_,qw (score browser start);
			next if grep $k eq $_->{d},@all_survey_fields;
			next if $vars->{$k};
			next if $externals->{$k};
			# print "found an ete $k=$resp{$k}\n" unless $ete->{$k};
			$ete->{$k}++;
		}
	}
}
$err->I("Building Header") unless $one_line_output;
# print "variables=$variables vars= ".Dumper $vars;
# print "masks=$masks mask_widths= ".Dumper $mask_widths;
# print "externals ".Dumper $externals;

my $codes_file = "$troot/$SID/final/${SID}_Codes_2.txt";
my $codes = getro TPerl::Dump ($codes_file);
my $max_code = {};
# my $codes = {};

my $mn_head = [];
my $mn_cols = [];
my $mn_vars = {};

my @head = ();
# Survey constant stuff
foreach my $f (@all_survey_fields){
	push @head,$f->{l};
}
# Question data
foreach my $q (@{$s->questions}){
	if ($mn_notes){
		my $type = $q->qtype();
		if (!grep ($type ==$_,7,8,11,20,22,27,28) or ($type ==7 and $q->external) ){
			my $ci = {};
			$ci->{lab} = uc ($q->label());
			$ci->{varname} = $q->varname || $ci->{lab};
			$mn_vars->{$ci->{varname}}++;
			push @$mn_cols,$ci;
		}
	}
	foreach my $ci (@{$q->getDataInfo}){
		my $var = $ci->{var};
		push @head,$var;
		# max code is the biggest code used so far OR maximum numeric recode / biggest var_label OR 500...
		# this used to be 50 but that conflicts with tabs if the Q has more than 50 attributes
		# this change was a request from Jan
		# jello - 5/5/2011
		# numbers get sorted after strings....
		$max_code->{$var} = (sort {$a <=> $b} values %$_)[-1] if $_ = $codes->{$var};
		unless ($max_code->{$var}){
			my @list = ();
			push @list,@$_ if $_ = $q->recodes;
			push @list,keys %$_ if $_ = $ci->{val_label};
			$max_code->{$var} = (sort {$a <=> $b} @list)[-1];
			$max_code->{$var} ||= 500;
		}
		# Now check that exising codes do not clash with any recodes or val_labels
		my $cds = $codes->{$var};
		foreach my $oth (keys %$cds){
			my $ecd = $cds->{$oth};
			if ($ci->{val_label} and exists $ci->{val_label}->{$ecd}){
				delete $cds->{$oth};
				$cds->{$oth}= ++$max_code->{$var};
				$err->W("Moved code for '$oth' in column $var from $ecd to $cds->{$oth} to avoid clash with (new) $ci->{val_label}->{$ecd}");
			}
			if ($q->recodes && grep $ecd eq $_,@{$q->recodes}){
				delete $cds->{$oth};
				$cds->{$oth}= ++$max_code->{$var};
				$err->W("Moved code for $oth in column $var from $ecd to $cds->{$oth} to avoid clash with (new) recode");
			}
		}
	}
}
# externals and vars and masks.
#

my $mn_extras = [
	{label=>'Seqno',key=>'seqno'},
];

if ($mn_notes){
	my $opt = $s->options;
	if ($opt->{ivor_interview}){
		push @$mn_extras,
			{label=>'FamNo',key=>'ext_fam_no'},
			{label=>'IdNo',key=>'ext_id_no'},
		;
	}
}

my $mn_exts = {}; ## some varnames are the same across many questions.
if ($mn_notes){
	foreach my $ex (@$mn_extras){
		push @$mn_head,$ex->{label};
	}
	foreach my $ci (@$mn_cols){
		$ci->{ext} = $mn_exts->{$ci->{varname}}++ if $mn_vars->{$ci->{varname}}>1;
		my $base = $ci->{varname}.$ci->{ext};
		push @$mn_head,$base."_$_" foreach qw (mn rf dk);
	}
	print $mn_fh join ("\t",@$mn_head)."\n";
	### Check for dupes.
	my $mn_head_elems = {};
	$mn_head_elems->{$_}++ foreach @$mn_head;
	foreach my $h (sort keys %$mn_head_elems){
		$err->E("Margin note column $h is repeated $mn_head_elems->{$h} times") if $mn_head_elems->{$h} >1;
	}
}


push @head,$_ foreach sort keys %$externals;
push @head,$_ foreach sort keys %$vars;
push @head,$_ foreach sort keys %$ete;
# make sure the same head dpoes not get on twice.
{
	my $head_elem = {};
	$head_elem->{$_}++ foreach @head;
	foreach my $h (sort keys %$head_elem){
		$err->E("column $h is repeated $head_elem->{$h} times") if $head_elem->{$h} >1;
	}
}
if ($masks){
	foreach my $mn (keys %$mask_widths){
		push @head,map "mask_${mn}x$_", 1..$mask_widths->{$mn};
		push @head,map "maskt_${mn}x$_", 1..$mask_widths->{$mn};
	}
}

print $ofh join ("\t",@head)."\n";
my $row_count =0; #rows in the output file.
my $head_len = @head;

$err->I("Building Data file") unless $one_line_output;
$err->ts(0);
my $dh = new DirHandle ($src) or $err->F("Could not access dir $src:$!");
while (my $f = $dh->read){
	last unless defined $f;
	my ($num_seq) = $f =~ /^D(\d+)\.pl$/i;
	next if $num_seq eq '' ;
	next if $case_hash and !$case_hash->{$num_seq};
	next if @$seq && !grep $f eq $_,@$seq ;
	my %resp = ();
	my @line=();
	eval read_file("$src/$f");
	$err->E("Eval error in $f:$@") if $@;
	next unless $include_status{$resp{status}};
	if ($start || $end){
		$resp{start} = $resp{modified} if $resp{start} eq '';
		next if $resp{start} < $start;
		next if $resp{modified} > $end;
		# foreach ($start, $resp{modified}, $end){
		# 	print "$_ ".$ez->epoch2text($_).' ';
		# }
		# print "$start $resp{start} $end\n";
	}
	if (!$numeric_passwords){
		next if $resp{token} =~ /^\d+$/;
	}
	if ($seqno_fix){
		my ($dnum) = $f =~ /(\d+)/;
		if ($resp{seqno} != $dnum){
			$err->W("Fixing seqno mismatch in $f $resp{seqno} should be $dnum");
			$resp{seqno}=$dnum;
		}
	}
	foreach my $f (@all_survey_fields){
		my $dates = dates (start=>$resp{start},end=>$resp{modified});
		if ($f->{s} ){
			push @line, $dates->{$f->{d}};
		}else{
			push @line,$resp{$f->{d}};
		}
	}
	my $msk_data = {};
	foreach my $q (@{$s->questions}){
		my $rfdk_found = {};
		my $rfdk_modif = {};
		my $data = {};
		my $cis = $q->getDataInfo;
		my $lab = $q->label;
		foreach my $ci (@$cis){
			my $var = $ci->{var};
			my $pos = $ci->{pos};
			my $mod = $ci->{val_if_true};
			my $key = $ci->{rkey};

			$data->{$var} = [split /$sep/,$resp{$key}] unless exists $data->{$var};
			# print "var=$var key=$key ".Dumper $data->{$var};
			my $val = $data->{$var}->[$pos];
			$val =~ s/^\s*(.*?)\s*$/$1/;
			$val =~ s/[\t\r\n]+//gs;
			$val =~ s/\\n/ /g;
			# print "lab=$lab var=$var val=$val mod=$mod data=".Dumper $data->{$var} if $lab eq 'A3';
			if ($mod && ($val ne '')){
				my $newval = $val;
				if (($mod =~ /^\d+$/)){
					if ($val){
						$newval = $mod ;
					}else{
						$newval=undef;
					}
				}elsif ( my ($add) = $mod=~/^\+(\d+)$/){
					$newval=$val+$add;
				}elsif ( $mod eq '!0'){
					$newval = '' if ($val eq '0');
					$newval = '' if ($val eq '-1');
				}elsif ( $mod eq 'date') {
					my $us_date = $s->options->{us_date};
					my $show_date = $q->show_date();
					if ($show_date){
						if ($val =~ /(\d*)\/(\d*)\/(\d*)/){
							$newval=sprintf("%2.2d/%2.2d/%d",$1,$2,$3);
							$newval=sprintf("%2.2d/%2.2d/%d",$2,$1,$3) if $us_date;
							# print "processing a date us=$us_date date=$show_date old=$val new=$newval\n";
						}
					}
				}else{
					$err->E(sprintf "Cannot handle val_if_true of '$mod' at var $var of question %s",$q->label);
				}
				$val=$newval;
			}
			# print "val=$val\n" if $lab eq 'A12C';
			## Now check for specifiers
			# print "lab=$lab val=$val\n";
			if (exists $ci->{autocode_after} and $val >$ci->{autocode_after}){
				# this used to be 50 but that conflicts with tabs if the Q has more than 50 attributes
				# this change was a request from Jan
				# jello - 5/5/2011
				my $min_new_code=500;
				if (my $spec = $ci->{specify}){
					my $oth;
					foreach my $skey (@$spec){
						$oth = lc $resp{$skey};
						$oth =~ s/^\s*(.*?)\s*$/$1/;
						last if $oth ne '';
					}
					$codes->{$var}->{$oth} ||= ++$max_code->{$var};
					$val = $codes->{$var}->{$oth};
				}else{
					# no key to lookin resp with
				}
			}
			# print "val=$val\n" if $lab eq 'A3';
			#
			## Now check for DK or RF
			# first build mask data
			my $dodr = 1;
			#if masked out set dodr=0..
			if (my $mhsh = $ci->{maskpos}){
				foreach my $inc (keys %$mhsh){
					my $msk_meth = $inc.'_include';
					my $msk_name = $q->$msk_meth;
					unless ($msk_data->{$msk_name}){
						my $mrespkey = "mask_$msk_name";
						if ($resp{$mrespkey} ne ''){
							$msk_data->{$msk_name} = [split /$sep/,$resp{$mrespkey}];
						}else{
							# $err->W("Q $lab '$msk_meth' mask $mrespkey does not exist in $f") ;
						}
					}
					if ($msk_data->{$msk_name}){
						# print "here $inc $lab $msk_name pos $mhsh->{$inc}".Dumper $msk_data->{$msk_name};
						$dodr = 0 if $msk_data->{$msk_name}->[$mhsh->{$inc}] ne '1';
					}
				}
			}
			if (my $sect = $ci->{section}){
				#could mask out by variable
				# print Dumper $q;
				my $pref = $q->var_prefix;
				my $vkey = lc ("v$pref$sect");
				if (exists $resp{$vkey}){
					$dodr = 0 if $resp{$vkey} < 1;
					# print "Found $vkey=$resp{$vkey} dodr=$dodr\n";
				}
			}
			foreach my $dr (qw(dk rf)){
				next unless $rfdk->{$dr};
				if ($resp{"$dr$key"}){
					$rfdk_found->{$dr}++;
					if ($val eq ''){
						if ($dodr){
							$rfdk_modif->{$dr}++;
							$val=$rfdk->{$dr};
						}
					}
				}
			}
			push @line,$val
		}
		foreach (qw(dk rf)){
			# $err->W("No blank data for '$_' in $resp{seqno}:$lab") if $rfdk_found->{$_} and !$rfdk_modif->{$_};
		}
	}
	push @line,$resp{$_} foreach sort keys %$externals;
	push @line,$resp{$_} foreach sort keys %$vars;
	push @line,$resp{$_} foreach sort keys %$ete;
	if ($masks){
		foreach my $mn (keys %$mask_widths){
			foreach my $t ('_','t_'){
				my @ary = split /$sep/,$resp{"mask$t$mn"};
				if (@ary > $mask_widths->{$mn}){
					$err->F("This should never happen with mask $mn");
				}else{
					$ary[$mask_widths->{$mn}-1] = $ary[$mask_widths->{$mn}-1];
					push @line,@ary;
				}
			}
		}
	}
	my $line_len = @line;
	if ($head_len == $line_len){
		s/[\r\t\n]/ /gs foreach @line;
		print $ofh join ("\t",@line)."\n";
		$row_count++;
		print '.' if $dots;
		print "\n" if $dots && ! ($row_count % 60);
	}else{
		$err->E("Skipping line from $f because the header is $head_len and the line has $line_len entries");
	}
	if ($mn_notes){
		my $mn_line = [];
		foreach my $ex (@$mn_extras){
			push @$mn_line,$resp{$ex->{key}};
		}
		foreach my $ci (@$mn_cols){
			foreach my $bit (qw(mn rf dk)){
				my $key = $bit.'_Q'.$ci->{lab};
				# print "key=$key\n";
				my $val = $resp{$key};
				$val =~ s/^\s*(.*?)\s*$/$1/;
				$val =~ s/[\t\r\n]+//gs;
				# print "Found '$val' with '$key'\n" if $val;
				push @$mn_line,$val;
			}
		}
		print $mn_fh join ("\t",@$mn_line)."\n";
	}
}
$err->ts(1) if $debug;
print "\n" if $dots;
$err->I( "$row_count rows processed") unless $one_line_output;
#### Make the q3_Codes.txt files
# print "Codes ". Dumper $codes;

####Once everyoneis using Codes_2.txt then get rid of the bit that 
# writes Codes.txt....

foreach my $lab (keys %$codes){
	delete $codes->{$lab} unless keys %{$codes->{$lab}};
}

justput TPerl::Dump ($codes_file,$codes);
if ($do_specify_files){
	foreach my $q (keys %$codes){
		my $fname = join '/',$troot,$SID,'final',"specify_$q.txt";
		my $fh = new FileHandle ("> $fname") or $err->F("Could not open $fname:$!");
		my $hsh = $codes->{$q};
		print $fh "Code\tResponse\n";
		foreach my $resp (sort {$hsh->{$a} <=> $hsh->{$b}} keys %$hsh){
			print $fh "$hsh->{$resp}\t$resp\n";
		}
	}
}
# if (my $fh = new FileHandle ("> $troot/$SID/final/${SID}_Codes.txt")){
# 	my $d = new Data::Dumper ([$codes],[qw(codes)]);
# 	print $fh $d->Dump;
# 	close $fh;
# }else{
# 	$err->E("Can't open $troot/$SID/final/${SID}_Codes.txt:$!");
# }
$err->pretty_count unless $one_line_output;
$err->I("$SID$name_ext $row_count row(s) of status @$status_inc from '$pretty_start' to '$pretty_end'") if $one_line_output;
